import { Prisma } from "@prisma/client";
import {
  objectType,
  extendType,
  nonNull,
  stringArg,
  arg,
  intArg,
  inputObjectType,
  enumType,
  list,
} from "nexus";

export const Link = objectType({
  // defines the name of the type you're building.
  name: "Link",
  // Adds different fields to the type.
  definition(t) {
    t.nonNull.int("id"); // adds non nullable id as an integer, and a description and url as strings.
    t.nonNull.string("description");
    t.nonNull.string("url");
    t.nonNull.dateTime("createdAt");
    t.field("postedBy", {
      type: "User",
      resolve(parent, args, context) {
        // similar to the User property, this lists the user who created this post, if any.
        return context.prisma.link
          .findUnique({ where: { id: parent.id } })
          .postedBy();
      },
    });
    t.nonNull.list.nonNull.field("voters", {
      // Similar to the above, this returns a list of unique voters by getting the user ID from the parent, finding the User, and then invoking voters recursively until it doesn't find a result.
      type: "User",
      resolve(parent, args, context) {
        return context.prisma.link
          .findUnique({ where: { id: parent.id } })
          .voters();
      },
    });
  },
});

export const Feed = objectType({
  name: "Feed",
  definition(t) {
    t.nonNull.list.nonNull.field("links", { type: Link }); // denotes a non-nullable list of Link type objects. Also the current return type of the feed query.
    t.nonNull.int("count"); // returns the number of links available in the database, total. Handy to have when using pagination, as the number of links returned usually differs from the total amount in the database.
  },
});

export const Sort = enumType({
  name: "Sort",
  members: ["asc", "desc"],
});

export const LinkOrderByInput = inputObjectType({
  name: "LinkOrderByInput",
  definition(t) {
    t.field("description", { type: Sort }),
      t.field("url", { type: Sort }),
      t.field("createdAt", { type: Sort });
  },
});

// extending the Query root type/factory type, adding a new root field to it called feed.
export const LinkQuery = extendType({
  type: "Query",
  definition(t) {
    t.nonNull.field("feed", {
      //defines the return type of the feed query as a non nullable array of link type objects. In schema definition language (sdl), it'll look look like [Link!]!
      type: "Feed",
      args: {
        filter: stringArg(), // The filter argument is optional. If you don't want to filter results, you can skip this.
        skip: intArg(), // represents the offset (how many indices to skip/ where to start)
        take: intArg(), // stipulates how many indices to display from the offset
        orderBy: arg({ type: list(nonNull(LinkOrderByInput)) }), // This arg takes a list of items of type LinkOrderByInput, coupled with an input specifying the sort order (ascending or descending)
      },
      async resolve(parent, args, context) {
        const where = args.filter  
          ? {
              OR: [
                { description: { contains: args.filter } },
                { url: { contains: args.filter } },
              ],
            }
          : {}; // In case you do end up using filter, this constructs a where object that expresses the filter condition. In this case, the filter condition is that the decription or the url (or both) should have some kind of substring that matches whatever's in the filter.

        const links = await context.prisma.link.findMany({
          where,
          skip: args?.skip as number | undefined, // takes the skip and take arguments as additional options, returning link records accordingly. If neither of these are passed, undefined gets passed to the Prisma client. Prisma interprets any undefined value as basically instructions to do absolutely nothing. We're writing this in this particular format due to the type mismatch between the type generated by Nexus and that expected by Prisma. Hence, the x as y type declaration.
          take: args?.take as number | undefined, // A further note: Prisma interprets Null as a specific value, whereas undefined means either do nothing or ignore this input.
          orderBy: args?.orderBy as
            | Prisma.Enumerable<Prisma.LinkOrderByWithRelationInput>
            | undefined,
        });

        const count = await context.prisma.link.count({ where }); 

        return {
          links,
          count
        };
      },
    });
  },
});

// Extends the mutation type to add a new root field, linkmutation.
export const LinkMutation = extendType({
  type: "Mutation",
  definition(t) {
    t.nonNull.field("post", {
      // names the mutation post, and returns a link object that is non nullable.
      type: "Link",
      args: {
        // Defines arguments passed to the graphql api endpoints. This is done similarly to REST api (why fix what isn't broken).
        description: nonNull(stringArg()),
        url: nonNull(stringArg()),
      },

      resolve(parent, args, context) {
        // Carries the arguments for the operation defined above; in this case, that's the URL and description of the link to be created. Think of these four as similar to req, res for REST endpoints. The parent carries the result of the previous resolver execution level.
        const { description, url } = args;
        const { userId } = context;

        if (!userId) {
          //checks for the presence of a userID. If there's none, throw an error.
          throw new Error("You need to be logged in for this.");
        }

        const newLink = context.prisma.link.create({
          data: {
            // associates the link with the currently logged in user.
            description,
            url,
            postedBy: { connect: { id: userId } },
          },
        });

        return newLink; // if anything but link is returned here, the generated types and TS will catch the mistake.
      },
    });
  },
});
